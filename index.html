---
highlighter: pygments
---
<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>purecollections by btj</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">purecollections</h1>
      <h2 class="project-tagline">Purely functional data structures for Java</h2>
      <a href="https://rawgit.com/btj/purecollections/master/docs/index.html" class="btn">View Javadoc</a>
      <a href="https://github.com/btj/purecollections/releases/download/v1.0/purecollections-1.0.zip" class="btn">Download Latest Release</a>
      <a href="https://github.com/btj/purecollections" class="btn">View on GitHub</a>
    </section>

    <section class="main-content">
      <p>Java's standard collection classes in the java.util package are mutable. As a result, passing instances of these classes between modules requires special care, such as making copies or wrapping them in unmodifiable wrappers, to avoid inadvertent modifications of a module's internal state representation by other modules, a problem known as <strong>representation exposure</strong>.</p>

<p>For example, consider a Person class that maintains a map of children and a list of telephone numbers. We show two variants of each getter: one which returns an unmodifiable wrapper, and one which creates a copy. Note that the public constructor that accepts initial values for the children and the phone numbers needs to defensively create a copy of the incoming collections.</p>

{% highlight java %}
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Person {

    private final Map&lt;String, Person&gt; children;
    private final Map&lt;String, Person&gt; childrenUnmodifiableWrapper;
    private final List&lt;String&gt; phoneNumbers;
    private final List&lt;String&gt; phoneNumbersUnmodifiableWrapper;

    private Person(Map&lt;String, Person&gt; children, List&lt;String&gt; phoneNumbers, boolean dummy) {
        this.children = children;
        this.childrenUnmodifiableWrapper = Collections.unmodifiableMap(this.children);
        this.phoneNumbers = phoneNumbers;
        this.phoneNumbersUnmodifiableWrapper = Collections.unmodifiableList(this.phoneNumbers);
    }

    public Person(Map&lt;String, Person&gt; children, List&lt;String&gt; phoneNumbers) {
        // Create defensive copies
        this(new HashMap&lt;String, Person&gt;(children), new ArrayList&lt;String&gt;(phoneNumbers), false);
    }

    public Person() {
        this(new HashMap&lt;String, Person&gt;(), new ArrayList&lt;String&gt;(), false);
    }

    public Map&lt;String, Person&gt; getChildren1() {
        return childrenUnmodifiableWrapper;
    }

    public Map&lt;String, Person&gt; getChildren2() {
        return new HashMap&lt;String, Person&gt;(children);
    }

    public Person addChild(String name) {
        Person child = new Person();
        children.put(name, child);
        return child;
    }

    public List&lt;String&gt; getPhoneNumbers1() {
        return phoneNumbersUnmodifiableWrapper;
    }

    public List&lt;String&gt; getPhoneNumbers2() {
        return new ArrayList&lt;String&gt;(phoneNumbers);
    }

    public void addPhoneNumber(String phoneNumber) {
        phoneNumbers.add(phoneNumber);
    }

}
{% endhighlight %}

<p>This project offers a simpler solution to the representation exposure problem. It provides a small library of <strong>purely functional</strong> data structures: a purely functional list data structure called PList, and a purely functional map data structure called PMap. Using purely functional data structures, which are inherently immutable, eliminates the representation exposure problem without wrapping or copying.</p>

<p>We can simplify the example using the purely functional PMap and PList data structures as follows. Note that no copying or wrapping is necessary, either for incoming or for outgoing collections. Since PMap and PList are classes that have no public or protected constructors, there can be no instances of these types that accidentally or maliciously exhibit mutable or otherwise incorrect behavior.</p>

<pre><code>import purecollections.PMap;
import purecollections.PList;

class Person {

    private PMap&lt;String, Person&gt; children;
    private PList&lt;String&gt; phoneNumbers;

    public Person(PMap&lt;String, Person&gt; children, PList&lt;String&gt; phoneNumbers) {
        this.children = children;
        this.phoneNumbers = phoneNumbers;
    }

    public Person() {
        this(PMap.&lt;String, Person&gt;empty(), PList.&lt;String&gt;empty());
    }

    public PMap&lt;String, Person&gt; getChildren() {
        return children;
    }

    public Person addChild(String name) {
        Person child = new Person();
        children = children.plus(name, child);
        return child;
    }

    public PList&lt;String&gt; getPhoneNumbers() {
        return phoneNumbers;
    }

    public void addPhoneNumber(String phoneNumber) {
        phoneNumbers = phoneNumbers.plus(phoneNumber);
    }

}
</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/btj/purecollections">purecollections</a> is maintained by <a href="https://github.com/btj">btj</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
